use crate::maths::polynomial::Polynomial;
use crate::register_problem;
use fraction::GenericFraction;

type SignedFraction = GenericFraction<i64>;
type QPolynomial = Polynomial<SignedFraction>;

register_problem!(101, "Arranged probability", problem101);

fn optimum_polynomial(k: i64, p: &QPolynomial) -> QPolynomial {
    let mut x: Vec<SignedFraction> = Vec::new();
    let mut y: Vec<SignedFraction> = Vec::new();
    for n in 1..=k {
        x.push(SignedFraction::from(n));
        y.push(p.value(SignedFraction::from(n)));
    }

    if y.len() == 1 {
        return QPolynomial::from(&y);
    }

    let mut result= QPolynomial::new();
    for i in 0..x.len() {
        let mut pi = QPolynomial::from_n(y[i]);
        for j in 0..x.len() {
            if i != j {
                let mut f = x[i] - x[j];
                f = SignedFraction::from(1) / f;
                pi *= &QPolynomial::from(&vec![-x[j] * f, f]);
            }
        }
        result += &pi;
    }

    result
}

fn bad_optimum_polynomial(k: i64, p: &QPolynomial) -> SignedFraction {
    let op = optimum_polynomial(k, p);
    println!("{k} => {op}");
    if p == op {
        return SignedFraction::from(0);
    }
    for n in 1.. {
        let fraction_n = SignedFraction::from(n);
        let op_value = op.value(fraction_n);
        let p_value = p.value(fraction_n);
        if op_value != p_value {
            return op_value;
        }
    }

    panic!();
}

pub fn problem101() -> String {
    // If we are presented with the first k terms of a sequence it is impossible to say with
    // certainty the value of the next term, as there are infinitely many polynomial functions that
    // can model the sequence.
    //
    // As an example, let us consider the sequence of cube numbers. This is defined by the
    // generating function, u_n = n^3: 1, 8, 27, 64, 125, 216, ...
    //
    // Suppose we were only given the first two terms of this sequence. Working on the principle
    // that "simple is best" we should assume a linear relationship and predict the next term to be
    // 15 (common difference 7). Even if we were presented with the first three terms, by the same
    // principle of simplicity, a quadratic relationship should be assumed.
    //
    // We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for
    // the first k terms of a sequence. It should be clear that OP(k, n) will accurately generate
    // the terms of the sequence for n ≤ k, and potentially the first incorrect term (FIT) will be
    // OP(k, k+1); in which case we shall call it a bad OP (BOP).
    //
    // As a basis, if we were only given the first term of sequence, it would be most sensible to
    // assume constancy; that is, for n ≥ 2, OP(1, n) = u_1.
    //
    // Hence we obtain the following OPs for the cubic sequence:
    // 		OP(1, n) = 1			1, 1, 1, 1, ...
    // 		OP(2, n) = 7n−6         1, 8, 15, ...
    //		OP(3, n) = 6n²−11n+6    1, 8, 27, 58, ...
    //		OP(4, n) = n^3          1, 8, 27, 64, 125, ...
    //
    // Clearly no BOPs exist for k ≥ 4.
    //
    // By considering the sum of FITs generated by the BOPs (indicated in red above), we obtain
    // 1 + 15 + 58 = 74.
    //
    // Consider the following tenth degree polynomial generating function:
    //
    // un = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10
    //
    // Find the sum of FITs for the BOPs.
    let mut result = SignedFraction::from(0);
    let one = SignedFraction::from(1);
    let p = QPolynomial::from(&vec![one, -one, one, -one, one, -one, one, -one, one, -one, one]);

    for k in 1..p.len() {
        let bop = bad_optimum_polynomial(k as i64, &p);
        result += bop;
    }

    result.numer().unwrap().to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_problem101() {
        let result = problem101();
        assert_eq!(result, "37076114526");
    }
}
